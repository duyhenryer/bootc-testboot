name: Build bootc image

on:
  push:
    branches: [main]
    paths:
      - "Containerfile"
      - "repos/**"
      - "base/**"
      - "bootc/**"
  workflow_dispatch:
    inputs:
      base_distro:
        description: 'Base distro to build on'
        default: 'centos-stream9'
        type: choice
        options:
          - centos-stream9
          - centos-stream10
          - fedora-40
          - fedora-41
      platforms:
        description: 'Platforms to build (comma-separated)'
        required: true
        default: 'linux/amd64,linux/arm64'
      formats:
        description: 'Export formats (comma-separated, leave blank for no artifacts)'
        required: false
        default: 'qcow2,ami,raw,vmdk,anaconda-iso'

env:
  REGISTRY: ghcr.io
  IMAGE: ghcr.io/${{ github.repository }}
  BASE_IMAGE: ghcr.io/${{ github.repository }}-base

jobs:
  matrix:
    name: Set build matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
      artifact_matrix: ${{ steps.set.outputs.artifact_matrix }}
      distro: ${{ steps.set.outputs.distro }}
      has_artifacts: ${{ steps.set.outputs.has_artifacts }}
    steps:
      - id: set
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PLATFORMS="${{ inputs.platforms }}"
            DISTRO="${{ inputs.base_distro }}"
            FORMATS="${{ inputs.formats }}"
          else
            PLATFORMS="linux/amd64,linux/arm64"
            DISTRO="centos-stream9"
            FORMATS="qcow2,ami,raw,vmdk,anaconda-iso"
          fi
          
          echo "distro=$DISTRO" >> "$GITHUB_OUTPUT"
          
          MATRIX='{"include":['
          first=1
          IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
          for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
            ARCH="${PLATFORM#linux/}"
            if [ "$ARCH" = "arm64" ]; then
              RUNNER="ubuntu-24.04-arm"
            else
              RUNNER="ubuntu-latest"
            fi
            if [ $first -eq 0 ]; then MATRIX+=","; fi
            first=0
            MATRIX+="{\"distro\":\"$DISTRO\",\"platform\":\"$PLATFORM\",\"arch\":\"$ARCH\",\"runner\":\"$RUNNER\"}"
          done
          MATRIX+=']}'
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          
          if [ -z "$FORMATS" ]; then
            echo "has_artifacts=false" >> "$GITHUB_OUTPUT"
            echo "artifact_matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
          else
            echo "has_artifacts=true" >> "$GITHUB_OUTPUT"
            ARTIFACT_MATRIX='{"include":['
            first_art=1
            IFS=',' read -ra FORMAT_ARRAY <<< "$FORMATS"
            for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
              ARCH="${PLATFORM#linux/}"
              if [ "$ARCH" = "arm64" ]; then
                RUNNER="ubuntu-24.04-arm"
              else
                RUNNER="ubuntu-latest"
              fi
              for FMT in "${FORMAT_ARRAY[@]}"; do
                if [ $first_art -eq 0 ]; then ARTIFACT_MATRIX+=","; fi
                first_art=0
                ARTIFACT_MATRIX+="{\"distro\":\"$DISTRO\",\"platform\":\"$PLATFORM\",\"arch\":\"$ARCH\",\"runner\":\"$RUNNER\",\"format\":\"$FMT\"}"
              done
            done
            ARTIFACT_MATRIX+=']}'
            echo "artifact_matrix=$ARTIFACT_MATRIX" >> "$GITHUB_OUTPUT"
          fi

  test:
    name: Go tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v5
        with:
          go-version: "1.22"
      - name: Run tests
        run: |
          for d in repos/*/; do
            if [ -f "$d/go.mod" ]; then
              echo "==> Testing $d"
              (cd "$d" && go test -v ./...)
            fi
          done

  build:
    name: Build ${{ matrix.distro }} (${{ matrix.arch }})
    if: github.event_name != 'pull_request'
    runs-on: ${{ matrix.runner }}
    needs: [matrix, test]
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v6

      - name: Free up some disk space
        uses: jlumbroso/free-disk-space@54081f138730dfa15788a46383842cd2f914a1be
        with:
          tool-cache: true

      - name: Install skopeo and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Compute semantic version tag (vN)
        id: version
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="${{ env.IMAGE }}"
          EXISTING_TAGS=""
          if skopeo list-tags "docker://${IMAGE}" >/tmp/tags.json 2>/dev/null; then
            EXISTING_TAGS=$(jq -r '.Tags[]' /tmp/tags.json 2>/dev/null | grep -oE "^${{ matrix.distro }}-v[0-9]+$" || echo "")
          fi
          if [ -z "$EXISTING_TAGS" ]; then
            NEXT_TAG="v1"
            echo "No existing tags found. Starting with v1"
          else
            HIGHEST_VERSION=$(echo "$EXISTING_TAGS" | sed "s/^${{ matrix.distro }}-v//" | sort -n | tail -n1)
            NEXT_NUM=$((HIGHEST_VERSION + 1))
            NEXT_TAG="v${NEXT_NUM}"
            echo "Highest existing version: v${HIGHEST_VERSION}. Next version: ${NEXT_TAG}"
          fi
          echo "version=${NEXT_TAG}" >> "$GITHUB_OUTPUT"

      - name: Resolve strict BASE_IMAGE tagged version
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          EXISTING_TAGS=""
          if skopeo list-tags "docker://${{ env.BASE_IMAGE }}" >/tmp/tags.json 2>/dev/null; then
            EXISTING_TAGS=$(jq -r '.Tags[]' /tmp/tags.json 2>/dev/null | grep -oE "^${{ matrix.distro }}-v[0-9]+$" || echo "")
          fi
          if [ -z "$EXISTING_TAGS" ]; then
            echo "Warning: no valid vN tag found for base image, defaulting to latest"
            echo "base_tag=latest" >> "$GITHUB_OUTPUT"
          else
            HIGHEST_VERSION=$(echo "$EXISTING_TAGS" | sed "s/^${{ matrix.distro }}-v//" | sort -n | tail -n1)
            BASE_TAG="v${HIGHEST_VERSION}"
            echo "Resolved Base Image Tag to: $BASE_TAG"
            echo "base_tag=${BASE_TAG}" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-go@v5
        with:
          go-version: "1.22"

      - name: Build Go applications
        run: make apps VERSION=${{ steps.version.outputs.version }}

      - name: Build apps + image natively
        run: |
          podman build --platform ${{ matrix.platform }} \
            --build-arg BASE_DISTRO=${{ matrix.distro }} \
            --build-arg BASE_IMAGE_VERSION=${{ steps.resolve.outputs.base_tag }} \
            -t ${{ env.IMAGE }}:${{ matrix.distro }}-latest-${{ matrix.arch }} \
            -t ${{ env.IMAGE }}:${{ matrix.distro }}-${{ steps.version.outputs.version }}-${{ matrix.arch }} \
            -f Containerfile .

      - name: Login to GHCR
        run: echo "${{ github.token }}" | podman login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Push arch-specific image
        run: |
          podman push ${{ env.IMAGE }}:${{ matrix.distro }}-latest-${{ matrix.arch }}
          podman push ${{ env.IMAGE }}:${{ matrix.distro }}-${{ steps.version.outputs.version }}-${{ matrix.arch }}

  create-manifest:
    name: Create multi-platform manifests
    needs: [matrix, build]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      version: ${{ steps.manifest.outputs.version }}
    steps:
      - name: Log in to GHCR
        run: echo "${{ github.token }}" | podman login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Install skopeo
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Create and push manifests
        id: manifest
        run: |
          set -euo pipefail
          DISTRO="${{ needs.matrix.outputs.distro }}"
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PLATFORMS="${{ github.event.inputs.platforms }}"
          else
            PLATFORMS="linux/amd64,linux/arm64"
          fi
          
          IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
          ARCHS=()
          for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
            ARCHS+=("${PLATFORM#linux/}")
          done
          
          IMAGE="${{ env.IMAGE }}"
          
          LATEST_ARCH_TAG=""
          if skopeo list-tags "docker://${IMAGE}" >/tmp/tags.json 2>/dev/null; then
            LATEST_ARCH_TAG=$(jq -r '.Tags[]' /tmp/tags.json 2>/dev/null | grep -oE "^${DISTRO}-v[0-9]+-${ARCHS[0]}$" | sort -V | tail -n1 || echo "")
          fi
          
          if [ -n "$LATEST_ARCH_TAG" ]; then
            VERSION_TAG=$(echo "$LATEST_ARCH_TAG" | sed -E "s/^${DISTRO}-(v[0-9]+)-${ARCHS[0]}$/\1/")
          else
            echo "Could not find recently pushed arch tags, defaulting to v1"
            VERSION_TAG="v1"
          fi
          
          for TAG_TYPE in "latest" "$VERSION_TAG"; do
            MANIFEST_TAG="${DISTRO}-${TAG_TYPE}"
            echo "Creating manifest for $IMAGE:$MANIFEST_TAG"
            
            podman manifest create "$IMAGE:$MANIFEST_TAG"
            for ARCH in "${ARCHS[@]}"; do
              MANIFEST_IMAGE="$IMAGE:$MANIFEST_TAG-$ARCH"
              echo "Adding $MANIFEST_IMAGE to manifest"
              podman manifest add "$IMAGE:$MANIFEST_TAG" "$MANIFEST_IMAGE"
            done
            
            echo "Pushing manifest $IMAGE:$MANIFEST_TAG"
            podman manifest push "$IMAGE:$MANIFEST_TAG" "docker://$IMAGE:$MANIFEST_TAG"
            podman manifest rm "$IMAGE:$MANIFEST_TAG" || true
          done
          
          echo "version=$VERSION_TAG" >> "$GITHUB_OUTPUT"

  build-artifacts:
    name: Artifacts (${{ matrix.format }}) (${{ matrix.arch }})
    needs: [matrix, create-manifest]
    if: needs.matrix.outputs.has_artifacts == 'true'
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.artifact_matrix) }}
    steps:
      - uses: actions/checkout@v6

      - name: Free up some disk space
        uses: jlumbroso/free-disk-space@54081f138730dfa15788a46383842cd2f914a1be
        with:
          tool-cache: true

      - name: Login to GHCR (sudo for storage)
        run: echo "${{ github.token }}" | sudo podman login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Pull target app image into system storage
        run: |
          TARGET_IMAGE="${{ env.IMAGE }}:${{ matrix.distro }}-${{ needs.create-manifest.outputs.version }}-${{ matrix.arch }}"
          echo "Pulling $TARGET_IMAGE before artifact creation to fix 'image not known' error..."
          sudo podman pull $TARGET_IMAGE

      - name: Build artifact (${{ matrix.format }})
        run: |
          mkdir -p output
          TARGET_IMAGE="${{ env.IMAGE }}:${{ matrix.distro }}-${{ needs.create-manifest.outputs.version }}-${{ matrix.arch }}"
          
          sudo podman run \
            --rm \
            --privileged \
            --security-opt label=type:unconfined_t \
            -v /var/lib/containers/storage:/var/lib/containers/storage \
            -v $(pwd)/builder:/builder \
            -v $(pwd)/output:/output \
            quay.io/centos-bootc/bootc-image-builder:latest \
            --type ${{ matrix.format }} \
            --config /builder/${{ matrix.format }}/config.toml \
            --chown $(id -u):$(id -g) \
            $TARGET_IMAGE

      - name: Package artifact as OCI and push
        run: |
          cat > output/Containerfile.scratch <<EOF
          FROM scratch
          COPY . /
          EOF
          
          ARTIFACT_IMAGE=${{ env.IMAGE }}-${{ matrix.distro }}-${{ matrix.format }}
          IMAGE_TAG=${ARTIFACT_IMAGE}:${{ needs.create-manifest.outputs.version }}-${{ matrix.arch }}
          LATEST_TAG=${ARTIFACT_IMAGE}:latest-${{ matrix.arch }}
          
          cd output
          sudo buildah bud --tag $IMAGE_TAG --tag $LATEST_TAG -f Containerfile.scratch .
          
          echo "${{ github.token }}" | sudo buildah login ghcr.io -u "${{ github.actor }}" --password-stdin
          sudo buildah push $IMAGE_TAG
          sudo buildah push $LATEST_TAG

  create-artifact-manifest:
    name: Create multi-platform artifact manifests
    needs: [matrix, create-manifest, build-artifacts]
    if: needs.matrix.outputs.has_artifacts == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Log in to GHCR
        run: echo "${{ github.token }}" | podman login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Create and push artifact manifests
        run: |
          set -euo pipefail
          DISTRO="${{ needs.matrix.outputs.distro }}"
          VERSION_TAG="${{ needs.create-manifest.outputs.version }}"
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PLATFORMS="${{ github.event.inputs.platforms }}"
            FORMATS="${{ github.event.inputs.formats }}"
          else
            PLATFORMS="linux/amd64,linux/arm64"
            FORMATS="qcow2,ami,raw,vmdk,anaconda-iso"
          fi
          
          IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
          ARCHS=()
          for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
            ARCHS+=("${PLATFORM#linux/}")
          done
          
          IFS=',' read -ra FORMAT_ARRAY <<< "$FORMATS"
          
          for FMT in "${FORMAT_ARRAY[@]}"; do
            ARTIFACT_IMAGE="${{ env.IMAGE }}-${DISTRO}-${FMT}"
            
            for TAG_TYPE in "latest" "$VERSION_TAG"; do
              MANIFEST_TAG="${TAG_TYPE}"
              echo "Creating manifest for $ARTIFACT_IMAGE:$MANIFEST_TAG"
              
              podman manifest create "$ARTIFACT_IMAGE:$MANIFEST_TAG"
              for ARCH in "${ARCHS[@]}"; do
                MANIFEST_IMAGE="$ARTIFACT_IMAGE:$MANIFEST_TAG-$ARCH"
                echo "Adding $MANIFEST_IMAGE to manifest"
                podman manifest add "$ARTIFACT_IMAGE:$MANIFEST_TAG" "$MANIFEST_IMAGE"
              done
              
              echo "Pushing manifest $ARTIFACT_IMAGE:$MANIFEST_TAG"
              podman manifest push "$ARTIFACT_IMAGE:$MANIFEST_TAG" "docker://$ARTIFACT_IMAGE:$MANIFEST_TAG"
              podman manifest rm "$ARTIFACT_IMAGE:$MANIFEST_TAG" || true
            done
          done
